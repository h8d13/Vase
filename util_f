#!/bin/bash
#utilities
show_help() {
    cat << 'EOF'
VaseOS - Arch Linux KDE Testing Suite

Usage: ./main [OPTIONS]

Options:
  -h,  --help                Show this help message
  -u,  --update              Check git for updates & pull submodules
  -ec, --edit-conf           Edit configuration file (...)

  -s,  --start               Start VM menu
  -q,  --quick <command>     Pass direct VM options (use "help" for list)
  -r,  --reset               Reset logs and settings

Examples:

  ./main -q help             Show VM quick commands

EOF
}
parse_args() {
    # If no args, show help
    if [ $# -eq 0 ]; then
        HELP=1
        return
    fi

    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                HELP=1
                shift
                ;;
            -r|--reset)
                RESET=1
                shift
                ;;
            -s|--start)
                START=1
                shift
                ;;
            -q|--quick)
                QUICK=1
                if [ -n "$2" ] && [[ ! "$2" == -* ]]; then
                    QUICK_CMD="$2"
                    shift 2
                else
                    QUICK_CMD=""
                    shift
                fi
                ;;
            -u|--update)
                UPDATE=1
                shift
                ;;
            -ec|--edit-conf)
                EDIT_CONF=1
                shift
                ;;
            *)
                echo "Unknown option: $1"
                echo "Run './main -h' for help"
                exit 1
                ;;
        esac
    done
}
exec_args() {
    case "$1" in
        HELP) [ "${HELP}" = "1" ] ;;
        RESET) [ "${RESET}" = "1" ] ;;
        START) [ "${START}" = "1" ] ;;
        QUICK) [ "${QUICK}" = "1" ] ;;
        UPDATE) [ "${UPDATE}" = "1" ] ;;
        EDIT_CONF) [ "${EDIT_CONF}" = "1" ] ;;
        *) return 1 ;;
    esac
}
get_edit_conf_cmd() {
    echo "${EDIT_CONF}"
}
get_quick_cmd() {
    echo "${QUICK_CMD}"
}
get_tui_cmd() {
    echo "${TUI_CMD}"
}
get_branch_name() {
    echo "${BRANCH_NAME}"
}
bytes_to_gib() {
    local bytes="$1"
    awk "BEGIN {printf \"%.1fGiB\", $bytes/1024/1024/1024}"
}
preop() {
    echo "[+] $1"
}
nlp() {
    echo ""
}
postop() {
    echo "[-] $1"
}
setup_cleanup() {
    trap cleanup EXIT INT TERM
}
cleanup() {
    if [ -n "$script_s" ] && [ "${TIMING}" = "1" ]; then
        local script_end
        script_end=$(date +%s%6N)
        local total_dur=$((script_end - script_s))

        # Format the duration
        local sec=$((total_dur / 1000000))
        local us=$((total_dur % 1000000))
        local ms=$((us / 1000))

        if [ $sec -gt 0 ]; then
            postop "Runtime: ${sec}.$(printf '%03d' $((us / 1000)))s"
        elif [ $ms -gt 0 ]; then
            postop "Runtime: ${ms}ms"
        else
            postop "Runtime: ${us}Î¼s"
        fi
    fi
    # Give back root-created files to the real user
    if [ -n "$real_user" ] && [ -n "${rel}${p_lib}" ] && dir_ex "${rel}${p_lib}"; then
        if dir_own "${rel}${p_lib}" "root"; then
            chown_all "$real_user" "${rel}${p_lib}"
        fi
    fi
    postop "Cleaning up..."
}
to_devnull(){
    "$@" >/dev/null 2>&1
}
silent_err(){
    "$@" 2>/dev/null
}
file_ex() {
    [ -f "$1" ]
}
file_mex() {
    if file_ex "$1"; then
       chmod +x "$1"
    fi
}
file_excreate() {
    if ! file_ex "$1"; then
        touch "$1"
    fi
}
dir_ex() {
    [ -d "$1" ]
}
dir_excreate() {
    if ! dir_ex "$1"; then
        mkdir -p "$1"
    fi
}
elev_type() {
    # shellcheck disable=SC2034  # priv_esc used by callers (vase)
    if command -v doas &>/dev/null; then
        priv_esc="doas"
    elif command -v sudo &>/dev/null; then
        priv_esc="sudo"
    elif command -v su &>/dev/null; then
        priv_esc="su"
    fi
}
get_real_user() {
    # Return the non-root user who invoked the elevated session
    if [ -n "$SUDO_USER" ]; then
        echo "$SUDO_USER"
    elif [ -n "$DOAS_USER" ]; then
        echo "$DOAS_USER"
    else
        logname 2>/dev/null || whoami
    fi
}
im_groot() {
    [ "$EUID" -eq 0 ]
}
am_iuser() {
    [ "$EUID" -ne 0 ]
}
im_elev() {
    [ -n "$SUDO_USER" ] || [ -n "$DOAS_USER" ]
}
chown_all() {
    chown -R "$1:$1" "$2"
}
who_dir() {
    stat -c '%U' "$1"
}
dir_own() {
    [ "$(who_dir "$1")" = "$2" ];
}
cmd_exists() {
    command -v "$1" >/dev/null 2>&1
}
cmd_check() {
    local cmd="$1"
    if cmd_exists "$cmd"; then
        reop "Found: $cmd"
        return 0
    else
        warn "Missing: $cmd"
        return 1
    fi
}
obanner() {
    echo "=== [$1] ==="
}
cbanner() {
    local label="$1"
    local banner_len=$((${#label} + 10))
    local i=0
    while [ $i -lt $banner_len ]; do
        printf '='
        i=$((i + 1))
    done
    echo
}
check_updates() {
    local repo_url="https://github.com/h8d13/Vase"

    preop "Checking for updates..."

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        warn "Not a git repository. Clone from ${repo_url}"
        return 1
    fi

    local local_hash
    local_hash=$(git rev-parse HEAD 2>/dev/null)
    if [ -z "$local_hash" ]; then
        warn "Failed to get local commit hash"
        return 1
    fi

    preop "Fetching from GitHub..."
    if ! GIT_TERMINAL_PROMPT=0 git fetch https://github.com/h8d13/Vase.git master --quiet 2>/dev/null; then
        warn "Failed to fetch updates. Check network connection."
        warn "Alternatively, run: git fetch origin master"
        return 1
    fi

    local remote_hash
    remote_hash=$(git rev-parse FETCH_HEAD 2>/dev/null)

    if [ -z "$remote_hash" ]; then
        warn "Failed to get remote commit hash"
        return 1
    fi

    if [ "$local_hash" = "$remote_hash" ]; then
        reop "Already up to date! (${local_hash:0:8})"
        return 0
    fi

    warn "Updates available!"
    echo ""
    echo "Current: ${local_hash:0:8}"
    echo "Latest:  ${remote_hash:0:8}"
    echo ""
    echo "Changes:"
    git log --oneline --decorate --color=always HEAD..FETCH_HEAD | head -10
    echo ""
    echo "To update run: git pull in project root or view diff git log"
    return 0
}
tree_dir() {
    if ! dir_ex "$1"; then
        return 1
    fi

    local current_tree
    current_tree=$(tree -a --dirsfirst --gitignore -I '.git|.md5|archinstall_official|archinstall_patch' "$1" 2>/dev/null)
    local current_hash
    current_hash=$(echo "$current_tree" | md5sum | awk '{print $1}')
    local stored_hash=""

    if file_ex "$1/.directory"; then
        stored_hash=$(grep "^# th: " "$1/.directory" 2>/dev/null | awk '{print $3}')
    fi

    if [ "$current_hash" != "$stored_hash" ]; then
        {
            echo "[Desktop Entry]"
            echo "Icon=folder-log"
            echo "# th: $current_hash"
            echo ""
            echo "$current_tree" | tail -n +2
        } > "$1/.directory"
    fi
}
