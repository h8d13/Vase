#!/bin/bash
#utilities
parse_args() {
    while [ $# -gt 0 ]; do
        case $1 in
            -r|--reset)
                RESET=1
                shift
                ;;
            -s|--start)
                START=1
                shift
                ;;
            -i |--isomod)
                ISO=1
                shift
                ;;
            -t |--tuimenu)
                TUI=1
                shift
                # Capture all remaining
                TUI_CMD="$*"
                break
                ;;
            -q|--quick)
                QUICK=1
                if [ -n "$2" ] && [[ ! "$2" == -* ]]; then
                    QUICK_CMD="$2"
                    shift 2
                else
                    QUICK_CMD=""
                    shift
                fi
                ;;
            -u|--update)
                UPDATE=1
                shift
                ;;
            -b|--bench)
                BENCH=1
                BENCH_CMD="$2"
                shift 2
                ;;
            -f|--flash)
                FLASH=1
                FLASH_DEVICE="$2"
                shift 2
                ;;
            -w|--workflow)
                WORKFLOW=1
                if [ -z "$2" ] || [[ "$2" == -* ]]; then
                    lsblk
                    echo "Error: -w requires a device argument (e.g., /dev/sdd)"
                    exit 1
                fi
                WORKFLOW_DEVICE="$2"
                shift 2
                ;;
            -d|--dev)
                DEV=1
                shift
                ;;
            -g|--grub)
                GRUB=1
                # Capture all remaining args for grome_lum
                GRUB_CMD="$*"
                shift
                break
                ;;
            *)
                echo "Unknown option: $1"
                exit 1
                ;;
        esac
    done
}
exec_args() {
    case "$1" in
        RESET) [ "${RESET}" = "1" ] ;;
        START) [ "${START}" = "1" ] ;;
        ISO) [ "${ISO}" = "1" ] ;;
        TUI)  [ "${TUI}" = "1" ] ;;
        QUICK) [ "${QUICK}" = "1" ] ;;
        UPDATE) [ "${UPDATE}" = "1" ] ;;
        BENCH) [ "${BENCH}" = "1" ] ;;
        FLASH) [ "${FLASH}" = "1" ] ;;
        WORKFLOW) [ "${WORKFLOW}" = "1" ] ;;
        DEV) [ "${DEV}" = "1" ] ;;
        GRUB) [ "${GRUB}" = "1" ] ;;
        *) return 1 ;;
    esac
}
get_quick_cmd() {
    echo "${QUICK_CMD}"
}
get_tui_cmd() {
    echo "${TUI_CMD}"
}
get_bench_cmd() {
    echo "${BENCH_CMD}"
}
get_flash_device() {
    echo "${FLASH_DEVICE}"
}
get_workflow_device() {
    echo "${WORKFLOW_DEVICE}"
}
get_grub_cmd() {
    echo "${GRUB_CMD}"
}
preop() {
    echo "[+] $1"
}
nlp() {
    echo ""
}
postop() {
    echo "[-] $1"
}
setup_cleanup() {
    trap cleanup EXIT INT TERM
}
cleanup() {
    if [ -n "$script_s" ] && [ "${TIMING}" = "1" ]; then
        local script_end
        script_end=$(date +%s%6N)
        local total_dur=$((script_end - script_s))

        # Format the duration
        local sec=$((total_dur / 1000000))
        local us=$((total_dur % 1000000))
        local ms=$((us / 1000))

        if [ $sec -gt 0 ]; then
            postop "Runtime: ${sec}.$(printf '%03d' $((us / 1000)))s"
        elif [ $ms -gt 0 ]; then
            postop "Runtime: ${ms}ms"
        else
            postop "Runtime: ${us}Î¼s"
        fi
    fi
    postop "Cleaning up..."
    # Add cleanup stuff here
}
to_devnull(){
    "$@" >/dev/null 2>&1
}
silent_err(){
    "$@" 2>/dev/null
}
file_ex() {
    [ -f "$1" ]
}
file_mex() {
    if file_ex "$1"; then
       chmod +x "$1"
    fi
}
file_excreate() {
    if ! file_ex "$1"; then
        touch "$1"
    fi
}
dir_ex() {
    [ -d "$1" ]
}
dir_excreate() {
    if ! dir_ex "$1"; then
        mkdir -p "$1"
    fi
}
im_groot() {
    [ "$EUID" -eq 0 ]
}
am_iuser() {
    [ "$EUID" -ne 0 ]
}
im_sudo() {
    [ -n "$SUDO_USER" ]
}
gui_what() {
    if [ -n "$SUDO_USER" ]; then
        local user_pid
        user_pid=$(pgrep -u "$SUDO_USER" -n)
        silent_err grep -z "^XDG_SESSION_TYPE=" /proc/"$user_pid"/environ | cut -d= -f2 | tr -d '\0'
    else
        echo "${XDG_SESSION_TYPE}"
    fi
}
gui_som() {
    local runtime_dir
    runtime_dir="/run/user/$(id -u "$1")"
    export XDG_RUNTIME_DIR="$runtime_dir"
}
chown_all() {
    chown -R "$1:$1" "$2"
}
who_dir() {
    stat -c '%U' "$1"
}
dir_own() {
    [ "$(who_dir "$1")" = "$2" ];
}
cmd_exists() {
    command -v "$1" >/dev/null 2>&1
}
cmd_check() {
    local cmd="$1"
    if cmd_exists "$cmd"; then
        reop "Found: $cmd"
        return 0
    else
        warn "Missing: $cmd"
        return 1
    fi
}
obanner() {
    echo "=== [$1] ==="
}
cbanner() {
    local label="$1"
    local banner_len=$((${#label} + 10))
    local i=0
    while [ $i -lt $banner_len ]; do
        printf '='
        i=$((i + 1))
    done
    echo
}
check_updates() {
    local repo_url="https://github.com/h8d13/Vase"

    preop "Checking for updates..."

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        warn "Not a git repository. Clone from ${repo_url}"
        return 1
    fi

    local local_hash=$(git rev-parse HEAD 2>/dev/null)
    if [ -z "$local_hash" ]; then
        warn "Failed to get local commit hash"
        return 1
    fi

    preop "Fetching from GitHub..."
    if ! GIT_TERMINAL_PROMPT=0 git fetch https://github.com/h8d13/Vase.git master --quiet 2>/dev/null; then
        warn "Failed to fetch updates. Check network connection."
        warn "Alternatively, run: git fetch origin master"
        return 1
    fi

    local remote_hash=$(git rev-parse FETCH_HEAD 2>/dev/null)

    if [ -z "$remote_hash" ]; then
        warn "Failed to get remote commit hash"
        return 1
    fi

    if [ "$local_hash" = "$remote_hash" ]; then
        reop "Already up to date! (${local_hash:0:8})"
        return 0
    fi

    warn "Updates available!"
    echo ""
    echo "Current: ${local_hash:0:8}"
    echo "Latest:  ${remote_hash:0:8}"
    echo ""
    echo "Changes:"
    git log --oneline --decorate --color=always HEAD..FETCH_HEAD | head -10
    echo ""
    echo "To update run: git pull in project root or view diff git log"
    return 0
}
tree_dir() {
    if ! dir_ex "$1"; then
        return 1
    fi

    local current_tree=$(tree -a --dirsfirst --gitignore -I '.git|.md5' "$1" 2>/dev/null)
    local current_hash=$(echo "$current_tree" | md5sum | awk '{print $1}')
    local stored_hash=""

    if file_ex "$1/.directory"; then
        stored_hash=$(grep "^# th: " "$1/.directory" 2>/dev/null | awk '{print $3}')
    fi

    if [ "$current_hash" != "$stored_hash" ]; then
        {
            echo "[Desktop Entry]"
            echo "Icon=folder-log"
            echo "# th: $current_hash"
            echo ""
            echo "$current_tree" | tail -n +2
        } > "$1/.directory"
    fi
}
