#!/bin/bash

. "$(dirname "$0")/grub_toggle"

if [[ "$1" == "-h" ]]; then cat << EOF
# -l        - List all GRUB menu entries
# -fb       - Find boot partition info
# -fc       - Find custom GRUB scripts
# -fc 40    - View specific script content
# -p        - Check os-prober status
# -p -p     - Run os-prober scan
# -p -a     - Toggle os-prober state
# -s        - Toggle submenu display
# -r        - Toggle remember last selection
# -a        - Regenerate GRUB config
EOF
    exit 0
fi

# Define system/default GRUB vs what people usually edit
default_stuff="^(00_header|10_linux|20_linux_xen|30_os-prober|30_uefi-firmware|41_custom|README)$"

if [[ "$1" == "-p" ]] || [[ "$1" == "--prober" ]]; then
    echo "=== OS Prober Status ==="
    if ! command -v os-prober &>/dev/null; then
        echo "os-prober not installed"
        echo "Install with: sudo pacman -S os-prober"
    else
        echo "os-prober installed: $(which os-prober)"

        # Check if enabled in GRUB config
        prober_line=$(grep "GRUB_DISABLE_OS_PROBER=" /etc/default/grub)
        if [[ "$prober_line" == "#"* ]]; then
            echo "Status: DISABLED (line commented)"
            echo "Current: $prober_line"
        elif [[ "$prober_line" == *"=true" ]]; then
            echo "Status: DISABLED (set to true)"
            echo "Current: $prober_line"
        elif [[ "$prober_line" == *"=false" ]]; then
            echo "Status: ENABLED"
        else
            echo "Status: NOT CONFIGURED"
        fi
        echo "Hint to Toggle: Use -p -a to enable/disable"
        echo "Hint to Probe: Use -p -p to scan for OSes (requires sudo)"

        # Handle -p flag to just run os-prober
        if [[ "$2" == "-p" ]] || [[ "$2" == "--probe" ]]; then
            echo -e "\n=== Running OS Prober Scan ==="
            os_found=$(os-prober 2>/dev/null)
            if [[ -n "$os_found" ]]; then
                echo "Found operating systems:"
                echo "$os_found" | while read line; do
                    device=$(echo $line | cut -d: -f1)
                    os_name=$(echo $line | cut -d: -f2)
                    os_type=$(echo $line | cut -d: -f3)
                    echo "  - $os_name [$os_type] on $device"
                done
            else
                echo "No other operating systems detected"
            fi
            exit 0
        fi

        # Handle -a flag to toggle os-prober state
        if [[ "$2" == "-a" ]] || [[ "$2" == "--apply" ]]; then
            grub_toggle "GRUB_DISABLE_OS_PROBER" "false" "true" "Toggling OS Prober Configuration"
            exit 0
        fi
    fi
    exit 0
fi

# Toggle submenu display
if [[ "$1" == "-s" ]] || [[ "$1" == "--submenu" ]]; then
    grub_toggle "GRUB_DISABLE_SUBMENU" "y" "" "GRUB Submenu Configuration"
    exit 0
fi

# Toggle remember last selection
if [[ "$1" == "-r" ]] || [[ "$1" == "--remember" ]]; then
    echo "=== GRUB Remember Last Selection ==="

    # Check if both settings are enabled
    default_line=$(grep "^GRUB_DEFAULT=" /etc/default/grub)
    savedefault_line=$(grep "^GRUB_SAVEDEFAULT=" /etc/default/grub)

    if [[ "$default_line" == "GRUB_DEFAULT=saved" ]] && [[ "$savedefault_line" == "GRUB_SAVEDEFAULT=true" ]]; then
        # Currently enabled - disable both
        echo "Current status: ENABLED (remembers last selection)"
        grub_toggle "GRUB_DEFAULT" "0" "" ""
        grub_toggle "GRUB_SAVEDEFAULT" "false" "" ""
        echo "Remember last selection DISABLED"
    else
        # Currently disabled - enable both
        echo "Current status: DISABLED (always boots first entry)"
        grub_toggle "GRUB_DEFAULT" "saved" "" ""
        grub_toggle "GRUB_SAVEDEFAULT" "true" "" ""
        echo "Remember last selection ENABLED"
    fi

    exit 0
fi

# List all GRUB menu entries
if [[ "$1" == "-l" ]] || [[ "$1" == "--list" ]]; then
    echo "=== GRUB Menu Entries ==="

    # Check submenu setting
    submenu_line=$(grep "GRUB_DISABLE_SUBMENU=" /etc/default/grub)
    submenu_disabled=false

    # Check if line is commented out (submenus enabled by default)
    if [[ "$submenu_line" == "#"* ]] || [[ -z "$submenu_line" ]]; then
        submenu_disabled=false
        echo "(Submenus enabled - showing hierarchical structure)"
    elif [[ "$submenu_line" == *"=y"* ]] || [[ "$submenu_line" == *"=true"* ]]; then
        submenu_disabled=true
        echo "(Submenus disabled - showing flat list)"
    else
        submenu_disabled=false
        echo "(Submenus enabled - showing hierarchical structure)"
    fi
    echo

    if [[ "$submenu_disabled" == "true" ]]; then
        # Flat list - show all menuentry items directly as GRUB displays them
        grep -E "menuentry " /boot/grub/grub.cfg | \
        sed -e "s/.*menuentry ['\"]\\([^'\"]*\\).*/• \\1/"
    else
        # Hierarchical - show submenus and indent their contents with logical grouping
        grep -E "menuentry " /boot/grub/grub.cfg | \
        sed -e "s/.*menuentry ['\"]\\([^'\"]*\\).*/\\1/" | \
        awk '
        {
            # Extract OS name and check if it is a fallback/advanced entry
            if ($0 ~ /fallback|advanced/) {
                # This is a sub-entry, indent it
                print "    • " $0
            } else {
                # Check if this is a duplicate main entry (like "Artix Linux (on /dev/sda3)")
                base_name = $0
                gsub(/\(on \/dev\/[^)]+\)/, "", base_name)  # Remove (on /dev/xxx) part
                gsub(/,.*/, "", base_name)  # Remove everything after comma
                gsub(/^ +| +$/, "", base_name)  # Trim spaces

                if (base_name in seen_base) {
                    # This is a duplicate base entry, treat as sub-entry
                    print "    • " $0
                } else {
                    # This is a new main entry
                    seen_base[base_name] = 1
                    print "• " $0
                }
            }
        }'
    fi

elif [[ "$1" == "-fb" ]] || [[ "$1" == "--findboot" ]]; then
    echo "=== Boot Partition Information ==="
    # Find /boot mount point from lsblk
    boot_info=$(lsblk -o NAME,SIZE,FSTYPE,MOUNTPOINT,UUID -r | grep "/boot$")

    if [[ -n "$boot_info" ]]; then
        # Parse the boot partition info
        IFS=' ' read -r name size fstype mountpoint uuid <<< "$boot_info"
        echo "Boot partition: /dev/$name"
        echo "Size: $size"
        echo "Filesystem: $fstype"
        echo "Mounted at: $mountpoint"
        echo "UUID: $uuid"

        # Show disk usage
        echo -e "\nDisk usage:"
        df -h /boot | tail -1 | awk '{printf "  Used: %s / %s (%s)\n", $3, $2, $5}'

        # Count kernels
        kernel_count=$(ls /boot/vmlinuz-* 2>/dev/null | wc -l)
        echo -e "\nKernels installed: $kernel_count"
        if [[ $kernel_count -gt 0 ]]; then
            echo "Kernels:"
            ls /boot/vmlinuz-* 2>/dev/null | sed 's/.*vmlinuz-/  • /'
        fi
    else
        echo "No separate /boot partition found"
        echo "Boot files on root partition"

        # Get root partition info
        root_info=$(lsblk -o NAME,SIZE,FSTYPE,MOUNTPOINT,UUID -r | grep " /$")
        if [[ -n "$root_info" ]]; then
            IFS=' ' read -r name size fstype mountpoint uuid <<< "$root_info"
            echo -e "\nRoot partition: /dev/$name"
            echo "Size: $size"
            echo "Filesystem: $fstype"
            echo "UUID: $uuid"
        fi

        # Check if /boot exists on root
        if [[ -d /boot ]]; then
            echo -e "\n/boot directory info:"
            boot_size=$(du -sh /boot 2>/dev/null | cut -f1)
            echo "  Size of /boot: $boot_size"

            # Show space usage
            df -h / | tail -1 | awk '{printf "  Partition usage: %s / %s (%s free: %s)\n", $3, $2, $5, $4}'

            # Count kernels
            kernel_count=$(ls /boot/vmlinuz-* 2>/dev/null | wc -l)
            initrd_count=$(ls /boot/initramfs-*.img 2>/dev/null | wc -l)

            echo -e "\nBoot contents:"
            echo "  Kernels: $kernel_count"
            if [[ $kernel_count -gt 0 ]]; then
                ls /boot/vmlinuz-* 2>/dev/null | sed 's/.*vmlinuz-/    • /'
            fi

            echo "  Initramfs images: $initrd_count"
            if [[ $initrd_count -gt 0 ]]; then
                ls /boot/initramfs-*.img 2>/dev/null | sed 's/.*initramfs-/    • /' | sed 's/\.img$//'
            fi

            # Check for GRUB
            if [[ -d /boot/grub ]]; then
                grub_size=$(du -sh /boot/grub 2>/dev/null | cut -f1)
                echo -e "\n  GRUB directory: $grub_size"
            fi

            # Check for EFI
            if [[ -d /boot/EFI ]] || [[ -d /boot/efi ]]; then
                efi_dir=$(ls -d /boot/[Ee][Ff][Ii] 2>/dev/null | head -1)
                efi_size=$(du -sh $efi_dir 2>/dev/null | cut -f1)
                echo "  EFI directory: $efi_size"
            fi
        fi
    fi

elif [[ "$1" == "-a" ]] || [[ "$1" == "--apply" ]]; then
    # Standalone -a just regenerates GRUB config
    echo "=== Regenerating GRUB Configuration ==="
    grub-mkconfig -o /boot/grub/grub.cfg
    echo "GRUB configuration updated successfully"
    exit 0

elif [[ "$1" == "-fc" ]] || [[ "$1" == "--findcustom" ]]; then
    if [[ -n "$2" ]]; then
        # View specific custom script
        script_name="$2"
        # Add wildcards if just a number is provided
        if [[ "$script_name" =~ ^[0-9]+$ ]]; then
            script_name="${script_name}_*"
        fi

        # Find and display the script
        for file in /etc/grub.d/$script_name*; do
            if [[ -f "$file" ]]; then
                echo "=== Content of $(basename $file) ==="
                # Stop at password line to avoid exposing sensitive data
                sed '/^password_pbkdf2/,$d' "$file"
                # Check if password was truncated
                if grep -q "^password_pbkdf2" "$file"; then
                    echo -e "\n[... password section hidden for security ...]"
                fi
                break
            fi
        done
    else
        echo "=== Custom GRUB Scripts & Entries ==="
        echo "Custom/non-standard scripts in /etc/grub.d/:"
        # List non-standard executable scripts (exclude default ones, but keep 40_custom since users edit it)
        for file in /etc/grub.d/*; do
            if [[ -x "$file" ]] && [[ ! "$(basename $file)" =~ $system_stuff ]]; then
                echo "  • $(basename $file)"
                # Try to extract menuentry names from the script
                grep -h "menuentry\|echo.*menuentry" "$file" 2>/dev/null | \
                grep -oE "(menuentry ['\"][^'\"]+|echo.*['\"]menuentry [^'\"]+)" | \
                sed "s/.*menuentry ['\"]\\([^'\"]*\\).*/      - \\1/" | head -5
            fi
        done
    fi
else
    # Default: show raw grep output
    grep -E "^menuentry|^submenu" /boot/grub/grub.cfg
fi
